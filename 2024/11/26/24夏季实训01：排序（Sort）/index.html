<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>24夏季实训01：排序（Sort） | 悲伤虾滑蛋</title><meta name="author" content="Zhou Chenyu"><meta name="copyright" content="Zhou Chenyu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="经典排序算法的优化及其测试2023-2024 夏季学期《计算机程序设计实训》课程报告(计算机工程与科学学院)摘 要 本文主要研究常用的经典排序算法在不同的数据规模,数据类型,数据分布的情况下的运行 效率,并将通过对冒泡排序、选择排序、快速排序三种经典算法的优化研究,探索不同排序算法在不同数 据场景下的表现。对所得出的数据,将以图表的方式做出具体分析。 关键词 排序;优化算法;算法评析; Optim">
<meta property="og:type" content="article">
<meta property="og:title" content="24夏季实训01：排序（Sort）">
<meta property="og:url" content="https://captainjack-ai.github.io/2024/11/26/24%E5%A4%8F%E5%AD%A3%E5%AE%9E%E8%AE%AD01%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88Sort%EF%BC%89/index.html">
<meta property="og:site_name" content="悲伤虾滑蛋">
<meta property="og:description" content="经典排序算法的优化及其测试2023-2024 夏季学期《计算机程序设计实训》课程报告(计算机工程与科学学院)摘 要 本文主要研究常用的经典排序算法在不同的数据规模,数据类型,数据分布的情况下的运行 效率,并将通过对冒泡排序、选择排序、快速排序三种经典算法的优化研究,探索不同排序算法在不同数 据场景下的表现。对所得出的数据,将以图表的方式做出具体分析。 关键词 排序;优化算法;算法评析; Optim">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://captainjack-ai.github.io/img/Picture/1.jpg">
<meta property="article:published_time" content="2024-11-26T06:52:19.000Z">
<meta property="article:modified_time" content="2025-02-09T09:41:02.117Z">
<meta property="article:author" content="Zhou Chenyu">
<meta property="article:tag" content="Practice">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://captainjack-ai.github.io/img/Picture/1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://captainjack-ai.github.io/2024/11/26/24%E5%A4%8F%E5%AD%A3%E5%AE%9E%E8%AE%AD01%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88Sort%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":250,"languages":{"author":"作者: Zhou Chenyu","link":"链接: ","source":"来源: 悲伤虾滑蛋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '24夏季实训01：排序（Sort）',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/Picture/1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">悲伤虾滑蛋</span></a><a class="nav-page-title" href="/"><span class="site-name">24夏季实训01：排序（Sort）</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">24夏季实训01：排序（Sort）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-26T06:52:19.000Z" title="发表于 2024-11-26 14:52:19">2024-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-09T09:41:02.117Z" title="更新于 2025-02-09 17:41:02">2025-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/">计算机科学</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="经典排序算法的优化及其测试"><a href="#经典排序算法的优化及其测试" class="headerlink" title="经典排序算法的优化及其测试"></a>经典排序算法的优化及其测试</h1><p>2023-2024 夏季学期《计算机程序设计实训》课程报告<br>(计算机工程与科学学院)<br>摘 要 本文主要研究常用的经典排序算法在不同的数据规模,数据类型,数据分布的情况下的运行 效率,并将通过对冒泡排序、选择排序、快速排序三种经典算法的优化研究,探索不同排序算法在不同数 据场景下的表现。对所得出的数据,将以图表的方式做出具体分析。</p>
<p>关键词 排序;优化算法;算法评析;</p>
<h3 id="Optimization-And-Testing-Of-Classical-Sorting-Algorithm"><a href="#Optimization-And-Testing-Of-Classical-Sorting-Algorithm" class="headerlink" title="Optimization And Testing Of Classical Sorting Algorithm"></a>Optimization And Testing Of Classical Sorting Algorithm</h3><p>2023-2024 SUMMER SEMESTER “COMPUTER PROGRAMMING TRAINING”<br>COURSE REPORT</p>
<p>(School of Computer Engineering and Science)<br>Abstract This paper mainly studies the efficiency of commonly used classical sorting algorithms in the case of different data scale, data type and data distribution, and explores the performance of different sorting algorithms in different data scenarios by optimizing three classical algorithms, namely bubble sorting, selection sorting and quick sorting. The resulting data will be analyzed concretely in the form of charts.</p>
<p>Key words Sorting; Optimization algorithm; Algorithm evaluation;</p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>排序是通过元素间的比较、交换或移动,使元素按某种顺序重新排列的过程。这是数 据结构与算法基础中非常重要的部分。不同的排序算法意味着在排序过程中对元素操作策 略的差异。了解并实现排序算法,并对其进行优化,有助于深入理解算法的时空复杂度, 从而加深对数据结构与算法基础的掌握。</p>
<p>因此,在此次实训中,我们小组对三种常见的排序算法——冒泡排序、选择排序和快 速排序——进行了实现、优化和深入分析。在研究过程中,为应对不同输入情况,我们还 对不同存储方式的 C-字符串的排序进行了实现与分析,这也加深了我们对指针的理解。本 文将详细阐述本次实训中我们小组的工作内容。</p>
<h1 id="2-经典排序算法的研究"><a href="#2-经典排序算法的研究" class="headerlink" title="2. 经典排序算法的研究"></a>2. 经典排序算法的研究</h1><h2 id="2-1-排序算法的实现、优化及测试"><a href="#2-1-排序算法的实现、优化及测试" class="headerlink" title="2.1 排序算法的实现、优化及测试"></a>2.1 排序算法的实现、优化及测试</h2><p>2.1.1 冒泡排序(Bubble Sort)的实现、优化及测试</p>
<h3 id="A-基础冒泡排序实现"><a href="#A-基础冒泡排序实现" class="headerlink" title="A.基础冒泡排序实现"></a>A.基础冒泡排序实现</h3><p>冒泡排序是一种比较简单的直观算法,它从第一个数字开始重复地去访问要排序的数 列,一次比较两个相邻的数字,找出这两个数字之间的大小关系,并根据要求看是否要交 换这两个数字。将数组里的所有数字比较过一次后,最后的一个数字一定是最大或最小 的,那么再次进行比较的时候,所比较的次数就会减一次,直到没有再进行交换,那么该 数列也就已经冒泡排序完成了。</p>
<p>实现步骤:<br>步骤 1:首先比较相邻两个元素。如果当前数字比第二个大,就将这两个数字交换。</p>
<p>步骤 2:比较下一个数字,对每一对相邻元素作同样的工作,从开始第一对到结尾的 最后一对,每次比较的数字是数组下标+1 的数字,这步做完后,最后的元素一定是这些数 字里面的最大值 步骤 3:重复以上的步骤,每次所比较的数字除掉最后一个,比较的次数-1。</p>
<p>步骤 4:每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较。</p>
<p>基础冒泡排序代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">I_Bubble</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">-—————————————————————————————————————</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;size-i; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &gt; a[j<span class="number">+1</span>]) &#123;</span><br><span class="line">temp = a[j]; a[j] = a[j<span class="number">+1</span>]; a[j<span class="number">+1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp; <span class="type">int</span> i, j; <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;size; i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-优化-去除不必要的比较"><a href="#B-优化-去除不必要的比较" class="headerlink" title="B. 优化:去除不必要的比较"></a>B. 优化:去除不必要的比较</h3><p>冒泡排序的时间复杂度:<br>快假设我们只冒泡排序 4 个数,也就是我们需要排序 3 趟,第一趟比较俩俩比较 3 次,第二趟 2 次,第三趟 1 次,合起来一共 3+2+1&#x3D;6 次。按照这样的算法,如果我们要冒 泡排序 N 个数,也就是我们需要冒泡排序 N-1 趟,即我们一共要比较(N-1)+(N-2)+(N- 3)+(N-4)+…+3+2+1&#x3D;(N-1)(1+N-1)&#x2F;2&#x3D;N(N-1)&#x2F;2。所以根据时间复杂度的算法,冒泡排序法的 时间复杂度为 O(N^2)。</p>
<p>目前,比较好的方法是引入一个额外变量 flag。它的思想是:在两个数据没有交换时 提前结束这一循环。</p>
<p>实现引入 flag 的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">I_Bubble</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> temp; <span class="type">int</span> i, j; <span class="type">int</span> flag=<span class="number">0</span>; <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;size; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;size-i; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &gt; a[j<span class="number">+1</span>]) &#123;</span><br><span class="line">temp = a[j]; a[j] = a[j<span class="number">+1</span>]; a[j<span class="number">+1</span>] = temp; flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-算法分析与测试-算法分析"><a href="#C-算法分析与测试-算法分析" class="headerlink" title="C. 算法分析与测试 算法分析"></a>C. 算法分析与测试 算法分析</h3><h4 id="1-空间复杂度分析"><a href="#1-空间复杂度分析" class="headerlink" title="1. 空间复杂度分析"></a>1. 空间复杂度分析</h4><p>—————————————————————————————————————<br>由于所有冒泡算法都是在地址上进行数据操作,因此算法本身并没有产生额外的内 存空间,因此,空间复杂度为(1)。</p>
<h4 id="2-稳定性分析"><a href="#2-稳定性分析" class="headerlink" title="2. 稳定性分析"></a>2. 稳定性分析</h4><p>a)基础冒泡排序 使用冒泡排序的过程中,较小的数据总是不断的被移动到前面,在排序过程中数 据前部会形成有序数列,按照基础冒泡排序的设计,前部的有序数组不会被再次排 序,因此基础冒泡排序是稳定排序。</p>
<p>b)flag 冒泡排序 由于引入的 flag 只作为判断数据是否有序的变量,并没有对数据进行额为操作,因 此基于基础冒泡排序的 flag 冒泡排序是稳定排序。</p>
<h4 id="3-时间复杂度分析"><a href="#3-时间复杂度分析" class="headerlink" title="3. 时间复杂度分析"></a>3. 时间复杂度分析</h4><p>不论在什么情况下,基础冒泡排序的时间复杂度都是O(n 2),但在加入 flag 优化的 判断下,基础冒泡排序在数据已经有序时能自动跳出循环,使得在处理顺序或基本有 序的数据时能达到O(n)的时间复杂度。</p>
<h4 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h4><p>a. 处理不同分布方式整型(int)数据的测试结果如下图 2.1.1:</p>
<p><img src="/img/3_image_0.png" alt="3_image_0.png"></p>
<p>对整型数据测试结果的分析:对于均匀分布、正态分布和完全逆序的整型数据,flag 优化 版用时是基础版的 0.5 倍左右。当处理完全顺序的整型数据时,由于只要进行一次循环, 所以 flag 优化版用时远小于基础版。</p>
<p>对浮点型数据测试结果的分析:对于均匀分布和正态分布的浮点型数据,flag 优化版用时 是基础版的 0.5 倍左右;处理完全逆序的浮点型数据时,flag 优化版用时稍长,约为基础 版的 0.75 倍。当处理完全顺序的浮点型数据时,由于只要进行一次循环,所以 flag 优化版 用时远小于基础版。 c.处理正态分布结构体类型(Score)数据的测试结果如下图 2.1.3:<br>b.处理不同分布方式浮点型(double)数据的测试结果如下图 2.1.2:</p>
<p><img src="/img/4_image_0.png" alt="4_image_0.png"></p>
<p><img src="/img/5_image_0.png" alt="5_image_0.png"></p>
<p>图 <strong>2.1.3</strong></p>
<p>对结构体类型数据测试结果的分析:<br>在对正态分布结构体类型数据的测试过程中发现,flag 优化版用时约为基础版冒泡排序 的 0.45 倍。由于结构体类型数据较为复杂,所以比起整型和浮点型数据,flag 优化版的优 势更加明显。</p>
<p>2.1.2 快速排序(Quick Sort)的实现、优化及测试</p>
<h3 id="A-基础快速排序实现"><a href="#A-基础快速排序实现" class="headerlink" title="A.基础快速排序实现"></a>A.基础快速排序实现</h3><p>快速排序通过多次比较和交换来实现排序,在排序过程中首先在数组中任意选取一个 数作为基准,然后将所有小于等于它的数放在它的左边,将所有大于等于它的数放在它的 右边,在对所有数都完成了一次比较之后,一次快速排序便完成了,这之后将这个数组以 基准为界分成两个数组再分别进行快速排序,多次递归后便得到了一个完全有序的数组。</p>
<p>实现步骤:<br>步骤 1:选取一个基准(一般为数组的第一个或最后一个元素)<br>步骤 2:分别标记数组的第二个元素和最后一个元素为头和尾 步骤 3:头标记向右跨过所有小于等于基准的元素停在第一个大于基准的元素,尾标 记向左跨过所有大于等于基准的元素停在第一个小于基准的元素 步骤 4:将被头和尾标记的元素交换 步骤 5:重复步骤 3-4,直到头标记和尾标记均在同一个元素上,将该元素和基准交 换,并以基准为界分为两个数组 步骤 6:分别对两个数组重复步骤 1-5 基础快速排序代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">I_Qsort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> size)</span> <span class="comment">// 快速排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pivot, temp; <span class="type">int</span> left=<span class="number">0</span>, right=size<span class="number">-1</span>; <span class="comment">// 下标(整数)</span></span><br><span class="line"><span class="keyword">if</span>(size&lt;=<span class="number">1</span>) <span class="keyword">return</span>; pivot = a[right]; <span class="comment">// 选择最后一个值为分界值 do &#123;</span></span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; a[left]&lt;=pivot) left++; <span class="comment">// 此处 &quot;&lt;=&quot; 是让与分界值相等的元 素暂时留在原地 while(left&lt;right &amp;&amp; a[right]&gt;=pivot)right--;// 此处 &quot;&gt;=&quot; 是让与分界值相等的元 素暂时留在原地 if(left &lt; right) &#123;</span></span><br><span class="line">temp=a[left]; a[left]=a[right]; a[right]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(left &lt; right);</span><br><span class="line">a[size<span class="number">-1</span>] = a[left]; a[left] = pivot; <span class="comment">// 找到分界点 I_Qsort(a, left); // 递归调用(左侧部分)</span></span><br><span class="line"><span class="built_in">I_Qsort</span>(a+left<span class="number">+1</span>, size-left<span class="number">-1</span>); <span class="comment">// 递归调用(右侧部分)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="B-优化-1-优化快速排序基准的选择"><a href="#B-优化-1-优化快速排序基准的选择" class="headerlink" title="B. 优化 1:优化快速排序基准的选择"></a>B. 优化 1:优化快速排序基准的选择</h4><p>快速排序的运行时间与划分是否对称有关。最坏情况下,每次划分过程产生两个区域 分别包 k 含 n-1 个元素和 1 个元素,其时间复杂度会达到 O(n^2)。在最好的情况下,每次 划分所取的基准都恰好是中值,即每次划分都产生两个大小为 n&#x2F;2 的区域。此时,快排的 时间复杂度为 O(nlogn)。所以基准的选择对快排而言至关重要。</p>
<p>目前,比较好的方法是使用三数取中选取基准。它的思想是:选取数组开头,中间和 结尾的元素,通过比较,选择中间的值作为快排的基准。其实可以将这个数字扩展到更大<br>(例如 5 数取中,7 数取中等)。这种方式能很好的解决待排数组基本有序的情况,而且选取 的基准没有随机性。</p>
<p>-—————————————————————————————————————<br>————————————————————————————————————</p>
<h4 id="实现三数取中的代码如下"><a href="#实现三数取中的代码如下" class="headerlink" title="实现三数取中的代码如下"></a>实现三数取中的代码如下</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">I_swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123; <span class="comment">// 交换函数 int temp = *a; *a = *b; *b = temp;</span></span><br><span class="line">&#125; <span class="function"><span class="type">int</span> <span class="title">I_medianOfThree</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="keyword">if</span> (arr[left] &gt; arr[mid])</span><br><span class="line"><span class="built_in">I_swap</span>(&amp;arr[left], &amp;arr[mid]);</span><br><span class="line"><span class="keyword">if</span> (arr[left] &gt; arr[right])</span><br><span class="line"><span class="built_in">I_swap</span>(&amp;arr[left], &amp;arr[right]);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[right])</span><br><span class="line"><span class="built_in">I_swap</span>(&amp;arr[mid], &amp;arr[right]); </span><br><span class="line"><span class="built_in">I_swap</span>(&amp;arr[mid], &amp;arr[right]); <span class="comment">//将中位数放在 right 的位置上,方便后续快排 return arr[right];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">I_ThreeNumber_Qsort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> size)</span> <span class="comment">// 三数取中法优化后快速排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pivot, temp; <span class="type">int</span> left=<span class="number">0</span>, right=size<span class="number">-1</span>; <span class="comment">// 定义下标 if(size&lt;=1) return; pivot = I_medianOfThree(a, left, right); // 调用取中位数的函数 do &#123;</span></span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; a[left]&lt;=pivot) left++; <span class="comment">// 此处 &quot;&lt;=&quot; 是让与分界值相等的元 素暂时留在原地 while(left&lt;right &amp;&amp; a[right]&gt;=pivot)right--;// 此处 &quot;&gt;=&quot; 是让与分界值相等的元 素暂时留在原地 if(left &lt; right) &#123;</span></span><br><span class="line">temp=a[left]; a[left]=a[right]; a[right]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(left &lt; right);</span><br><span class="line">a[size<span class="number">-1</span>] = a[left]; a[left] = pivot; <span class="comment">// 找到中位数 a[left] I_Qsort(a, left); // 递归调用 I_Qsort(a+left+1, size-left-1); // 递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>—————————————————————————————————————</p>
<h4 id="C-优化-2-序列长度达到一定大小后-使用插入排序"><a href="#C-优化-2-序列长度达到一定大小后-使用插入排序" class="headerlink" title="C. 优化 2:序列长度达到一定大小后,使用插入排序"></a>C. 优化 2:序列长度达到一定大小后,使用插入排序</h4><p>当快排达到一定深度后,划分的区间很小时,再使用快排的效率不高。当待排序列的 长度达到一定数值后,可以使用插入排序。由《数据结构与算法分析》(Mark Allen Weiness 所著)可知,当待排序列长度为 5~20 之间,此时使用插入排序能避免一些有害的退 化情形,在划分到很小的区间时,里面的元素已经基本有序了,再使用快排,效率就不高 了。所以,在结合插入排序后,程序的执行效率有所提高。</p>
<p>使用插入排序优化后的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">I_InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> <span class="comment">//插入排序(用于优化数据量较小时的快速排序)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i; <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> end = i; <span class="type">int</span> tmp = a[end + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; a[end]) &#123;</span><br><span class="line">a[end + <span class="number">1</span>] = a[end];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; end--;</span><br><span class="line">a[end<span class="number">+1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">I_Qsort_Inter</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> size)</span> <span class="comment">// 快速排序+插入排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( size&lt;<span class="number">15</span>) <span class="comment">//当数据量小于 15 时,使用插 入排序,防止递归调用浪费过多时间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">I_InsertSort</span>(a,size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="type">int</span> pivot, temp; <span class="type">int</span> left=<span class="number">0</span>, right=size<span class="number">-1</span>; <span class="comment">// 定义下标 if(size&lt;=1) return; pivot = a[right]; // 选择最后一个值为分界值 do &#123;</span></span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; a[left]&lt;=pivot) left++; <span class="comment">// 此处 &quot;&lt;=&quot; 是让与分界值相等的元 素暂时留在原地 while(left&lt;right &amp;&amp; a[right]&gt;=pivot)right--;// 此处 &quot;&gt;=&quot; 是让与分界值相等的元 素暂时留在原地 if(left &lt; right) &#123;</span></span><br><span class="line">temp=a[left]; a[left]=a[right]; a[right]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(left &lt; right);</span><br><span class="line">a[size<span class="number">-1</span>] = a[left]; a[left] = pivot; <span class="comment">// 找到分界点 I_Qsort(a, left); // 递归调用(左侧部分) I_Qsort(a+left+1, size-left-1); // 递归调用(右侧部分)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="D-算法分析与测试"><a href="#D-算法分析与测试" class="headerlink" title="D. 算法分析与测试"></a>D. 算法分析与测试</h5><p>算法分析 1. 空间复杂度分析 由于所有快速算法都是在地址上进行数据操作,因此算法本身并没有产生额外的 内存空间,因此,空间复杂度为(1)。</p>
<h5 id="2-稳定性分析-1"><a href="#2-稳定性分析-1" class="headerlink" title="2. 稳定性分析"></a>2. 稳定性分析</h5><p>对于快速排序,如果让其对一个有着重复数据的数组进行排序,若所选的基准正 好为重复数据的一个,则他们的相对顺序会被打乱,所有快速排序试一个不稳定的排 序算法。</p>
<h5 id="3-时间复杂度分析-1"><a href="#3-时间复杂度分析-1" class="headerlink" title="3. 时间复杂度分析"></a>3. 时间复杂度分析</h5><p>在每次取到的基准都能将数组平分,也就是最理想的情况下,确认第 1 个数 要遍历 n 个数,确认第 2 个数和第 3 个数需要遍历 n&#x2F;2 个数,确认第 4、5、6、7 个数各需要遍历 n&#x2F;4 个数。将分段缩小到 1,则需要分 x 次,即 1&#x3D;n&#x2F;(2^x), x&#x3D;log2n,即一共有 log2n 层将每一层都近似得看作遍历 n 个数,则总遍历个数为 n*log2n,即最优情况时间复杂度为 O(nlogn)。</p>
<p>而如果每次取到的基准都是数组中的最大值或最小值,也就是最差情况下, 确认第 1 个数要遍历 n 个数,确认第 2 个数要遍历 n-1 个数,以此类推,等差求 和得遍历个数为 n*(1+n)&#x2F;2,时间复杂度为 O(n^2)。</p>
<p>测试数据</p>
<p><img src="/img/10_image_0.png" alt="10_image_0.png"></p>
<p>a. 处理不同分布方式整型(int)数据的测试结果如下图 2.1.4:</p>
<p>图 2.1.4</p>
<h3 id="对整型数据测试结果的分析"><a href="#对整型数据测试结果的分析" class="headerlink" title="对整型数据测试结果的分析:"></a>对整型数据测试结果的分析:</h3><p>对于均匀分布和正态分布的整型数据,两种优化方案与基础的快速排序算法运行时间 差距不大,但当处理完全顺序分布以及完全逆序分布的数据时,两种优化方案在运行时间 上明显表现出优于基快速排序算法的性能,尤其是快速排序+三数取中法的优化方案相比 于基础快速排序算法可以实现大幅减少运行时间。</p>
<p>b.处理不同分布方式浮点型(double)数据的测试结果如下图 2.1.5:</p>
<p><img src="/img/11_image_0.png" alt="11_image_0.png"></p>
<p>图 <strong>2.1.5</strong></p>
<h4 id="对浮点型数据测试结果的分析"><a href="#对浮点型数据测试结果的分析" class="headerlink" title="对浮点型数据测试结果的分析:"></a>对浮点型数据测试结果的分析:</h4><p><img src="/img/11_Image_1.Png" alt="11_Image_1.Png"></p>
<p>在对浮点型数据的测试过程中发现,快速排序+插入排序的优化方法并没有在基础的排 序算法上有明显的提高,但是三数取中法的优化方案仍然在浮点数的测试中表现出优秀的 性能,相比于基础快速排序算法可以实现大幅减少运行时间。</p>
<h3 id="2-1-3-选择排序-Selection-Sort-的实现、优化及测试-A-基础选择排序实现"><a href="#2-1-3-选择排序-Selection-Sort-的实现、优化及测试-A-基础选择排序实现" class="headerlink" title="2.1.3 选择排序(Selection Sort)的实现、优化及测试 A.基础选择排序实现"></a>2.1.3 选择排序(Selection Sort)的实现、优化及测试 A.基础选择排序实现</h3><p>选择排序是最为简单实现的代码之一,以从小到大排序为例,首先需设立一个 min 以 记录目前最小元素的下标,以第一个地址为初始位置,依次与后续地址的元素值进行比 较,若比 min 所在地值更小则进行交换,全部比较完成后则交换对应初始位置与 min 的内 容,然后以第二个数为初始位置开始进行第二轮比较,以此类推,直至排序完成得到一个 完全有序的数组。</p>
<p>实现步骤:<br>步骤 1:设置一个最小值坐标 min,以及两个标记 i&#x3D;0,j 步骤 2:令 min&#x3D;i,j&#x3D;i 步骤 3:如果 min 所在位置的值大于 j 所在位置的大小便令 min 等于 j,j++<br>步骤 4:循环进行步骤 3 直到 j&gt;&#x3D;数组长度 步骤 5:如果 min 不等于 i,便交换 i 与 min 所在位置的值,i++<br>步骤 6:如果 i&lt;数组长度,则进行步骤 2 基础选择排序代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectDouble</span><span class="params">(<span class="type">double</span>* a, <span class="type">int</span> size)</span> </span>&#123; <span class="comment">// 选择排序 double t; int i, j, min = 0; for (int i = 0; i &lt; size; i++)&#123;</span></span><br><span class="line">min = i; <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; size; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (a[min] &gt; a[j])&#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">t = a[min]; a[min] = a[i]; a[i] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-优化-优化选择排序在遍历中比较值的个数"><a href="#B-优化-优化选择排序在遍历中比较值的个数" class="headerlink" title="B. 优化:优化选择排序在遍历中比较值的个数"></a>B. 优化:优化选择排序在遍历中比较值的个数</h3><p>在刚刚的基础版中,每次只能进行一个元素的交换,不妨在设置一个最大值 max 一同 进行运算,减少遍历次数,只需遍历一半便可达到目标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NewSelectDouble</span><span class="params">(<span class="type">double</span>* a, <span class="type">int</span> size)</span> <span class="comment">// 优化选择排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> t; <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, min = <span class="number">0</span>, max = size - <span class="number">1</span>; <span class="type">int</span> now = size / <span class="number">2</span>; <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; now; i++)&#123;</span><br><span class="line">min = i; max = size - i - <span class="number">1</span>; <span class="keyword">for</span> (j = i; j &lt; size - i; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (a[min] &gt; a[j]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125; <span class="keyword">if</span> (a[max] &lt; a[j]) &#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">t = a[min]; a[min] = a[i]; a[i] = t; <span class="keyword">if</span> (max == i) &#123;</span><br><span class="line">max = min;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">if</span> (max != (size - <span class="number">1</span> - i)) &#123;</span><br><span class="line">t = a[max]; a[max] = a[size - <span class="number">1</span> - i]; a[size - <span class="number">1</span> - i] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-算法分析与测试"><a href="#C-算法分析与测试" class="headerlink" title="C. 算法分析与测试"></a>C. 算法分析与测试</h3><p>算法分析 1. 空间复杂度分析 由于所有快速算法都是在地址上进行数据操作,因此算法本身并没有产生额外的内存 空间,因此,空间复杂度为(1)。</p>
<ol start="2">
<li>程序的稳定性<br>(1) 基础选择排序 该算法在选择最小值的过程中使用了交换操作,如果遇到相同的值,可能会改变他们 在数组中的相对位置,因此该算法不是稳定的的排序算法.</li>
</ol>
<h4 id="2-优化选择排序"><a href="#2-优化选择排序" class="headerlink" title="(2) 优化选择排序"></a>(2) 优化选择排序</h4><p>该算法在选择最小值和最大值的过程中使用了交换操作,如果遇到相同的值,可能会 改变他们在数组中的相对位置,因此该算法不是稳定的的排序算法</p>
<h4 id="3-时间复杂度"><a href="#3-时间复杂度" class="headerlink" title="3. 时间复杂度"></a>3. 时间复杂度</h4><p>(1) 基础选择排序 根据程序观察可得为双重循环,分别循环 n 次,n-i 次.此时时间复杂度为 O(n × n&#x2F;2 × 1),即 O(n^2)。</p>
<h4 id="2-优化选择排序-1"><a href="#2-优化选择排序-1" class="headerlink" title="(2) 优化选择排序"></a>(2) 优化选择排序</h4><p>根据程序观察可得依旧为双重循环,分别循环n&#x2F;2次,(n-i)&#x2F;2次,此时时间复杂度为 O((n-i)&#x2F;2 × n&#x2F;2 × 1),即 O(n^2)。</p>
<p>可见两种算法的时间复杂度其实是一致的,并无差别。</p>
<p>测试数据 a. 处理不同分布方式整型(int)数据的测试结果如下图 2.1.6:</p>
<p><img src="/img/14_image_0.png" alt="14_image_0.png"></p>
<p><img src="/img/14_image_1.png" alt="14_image_1.png"></p>
<p>对整型数据测试结果的分析:<br>对于均匀分布和正态分布的整型数据,优化方案与基础的选择排序算法运行时间差距 不大,但优化后的总是略强于基础方案,减少了运行时间 b.处理不同分布方式浮点型(double)数据的测试结果如下图 2.1.7:</p>
<p><img src="/img/15_image_0.png" alt="15_image_0.png"></p>
<p>图 <strong>2.1.7</strong></p>
<h4 id="对双精度浮点数据测试结果的分析"><a href="#对双精度浮点数据测试结果的分析" class="headerlink" title="对双精度浮点数据测试结果的分析:"></a>对双精度浮点数据测试结果的分析:</h4><p>对于均匀分布和正态分布的双精度浮点数据,优化方案与基础的选择排序算法运行时 间差距不大,但优化后的总是略强于基础方案,减少了运行时间 ,总的来看,在什么情况 下,优化后的算法总是强于基础版的。</p>
<h3 id="2-2-多种排序算法的联合测试"><a href="#2-2-多种排序算法的联合测试" class="headerlink" title="2.2 多种排序算法的联合测试"></a>2.2 多种排序算法的联合测试</h3><p>多种排序算法及其优化算法在不同的数据类型(整型,浮点型),不同的数据规模<br>(从 1024 到 32768),不同的数据分布(正态分布,均匀分布,完全顺序分布,完全逆序 分布)下的测试数据如下图 2.2.1 和图 2.2.2 所示:</p>
<p><img src="/img/16_image_0.png" alt="16_image_0.png"></p>
<p><img src="/img/16_image_1.png" alt="16_image_1.png"></p>
<p>图 <strong>2.2.1</strong></p>
<p><img src="/img/17_image_0.png" alt="17_image_0.png"></p>
<h4 id="图-2-2-2"><a href="#图-2-2-2" class="headerlink" title="图 2.2.2"></a>图 2.2.2</h4><p>根据上述数据分析可知,快速排序算法在数据量较大时相比于其他两种排序算法表现 出明显的优势(尤其是在正态分布和均匀分布时),快速排序的两种优化方案中,快速排 序+三数取中的优化方式表现更为突出,可以大幅降低运行时间。冒泡排序时三种算法中 平均耗时最长的一种排序算法,采用标记法(flag)优化后也不能将运行时间减少到到其 他两种算法的平均水平,且在某些情况下冒泡排序的优化方案并没有起到稳定的作用。选 择排序的优化方案可以稳定的在不同的数据环境下优化程序运行时间。</p>
<h1 id="2-3-三种经典排序算法稳定性分析"><a href="#2-3-三种经典排序算法稳定性分析" class="headerlink" title="2.3 三种经典排序算法稳定性分析"></a>2.3 三种经典排序算法稳定性分析</h1><p>对稳定性的理解:假定在待排序的记录序列中,存在多个具有相同关键字的记录, 若经过排序,这些记录相对次序保持不变,即在原序列中 r[i]&#x3D;fj],且 r[i]在 r[i]之前, 而在排序后的序列中,r[i]仍在 r[j]之前,则称此排序算法稳定:否则称为不稳定。<br><img src="/img/sort01.png" alt="sort01.png"></p>
<p><img src="/img/sort02.png" alt="sort02.png"></p>
<p><img src="/img/sort03.png" alt="sort03.png"></p>
<p>从理论上来看,快速排序在中枢元素和 a[j]交换的时候,很有可能把前面的元素的稳 定性打乱,所以快速排序是一个理论上就极不稳定的排序算法,不稳定发生在中枢元素和 a[j]交换的时刻,从此实验结果来看,当数据集为 1024 和 65536 时,都存在顺序错乱的情 况,故快速排序为较前面两种排序方式稳定性更低的排序方法。</p>
<h1 id="3-C-字符串数组排序研究"><a href="#3-C-字符串数组排序研究" class="headerlink" title="3. C-字符串数组排序研究"></a>3. C-字符串数组排序研究</h1><h3 id="3-1-思考题"><a href="#3-1-思考题" class="headerlink" title="3.1 思考题"></a>3.1 思考题</h3><h4 id="1-下面的测试函数中"><a href="#1-下面的测试函数中" class="headerlink" title="1. 下面的测试函数中"></a>1. 下面的测试函数中</h4><p>(1) 请思考然后进行程序验证 sizeof(strA), sizeof(strB), sizeof(strC), sizeof(strD)各为多少字 节,这些字节位于内存什么区域(代码区、全局数据区、栈区、堆区)?</p>
<p>答:sizeof(strA)为 300,sizeof(strB)为 60,sizeof(strC)和 sizeof(strD)均为 4。</p>
<p>由于 strA 是一个二维字符数组,而二维字符数组的大小由其所有元素的总字节数决定,包 括所有字符串常量及数组本身所需的存储空间。且 strA 因为其大小一开始就定好了所以其 存储在栈内存中,其存储的字符串常量都直接在代码段(常量池)。由于 strB 是一个指针 数组,指针数组的大小取决于数组中指针的数量乘以每个指针的大小。strB 中的每个指针 指向一个字符串常量,故 strB 本身存储在栈内存中。而因为 strC 和 strD 都是指向指针 的指针,并且在初始化时被赋予了 NULL 值,即它们目前并未指向有效的内存位置。这 些指针本身存储在栈内存中。</p>
<p>(附加解释:由于 strB 中的指针所指向的常量字符串是存储在常量池里的,而 strcmp()是 交换指针,因此 BubbleA()能对 strB 排序。但 BubbleB()不能对 strA 排序。)<br>(2) strA、strB、strC、strD 联系的 C-字符串数组的内容存储在内存的什么区域?它们的读&#x2F;<br>写属性(是否可读、可写)如何?</p>
<p>答:strA 中的字符串常量存储在代码区,是只读不可修改的,而 strB 中的指针存储在栈 上,指向的字符串在静态数据区,也是只读不可修改的,而 strC 和 strD 指向可以是任意内 存区域,其读写属性取决于所指对象的具体存储区域及其本身是否被分配了可写的内存空 间。</p>
<h4 id="2-设计-Bubblea-Bubbleb-两个函数之前-思考"><a href="#2-设计-Bubblea-Bubbleb-两个函数之前-思考" class="headerlink" title="2.设计 Bubblea,Bubbleb 两个函数之前,思考"></a>2.设计 Bubblea,Bubbleb 两个函数之前,思考</h4><p>(1) 如何比较两个字符串的内容?</p>
<p>答:通过 ASCⅡ码即字典进行比较。</p>
<p>(2) 存储在什么区域的字符串能交换其内容?</p>
<p>答:只有存储在栈和堆区的字符串才能交换其内容。</p>
<p>(3) 若不能交换字符串的内容,排序操作中交换什么?</p>
<p>答:通常会交换指向字符串的指针,而不是交换字符串内容本身。</p>
<p>3.GetStringsA 和 <strong>GetStringB</strong> 函数的第一个形式参数为什么需要用到三级指针,如果</p>
<h4 id="仅用二级指针会怎样"><a href="#仅用二级指针会怎样" class="headerlink" title="仅用二级指针会怎样?"></a>仅用二级指针会怎样?</h4><p>答:因为需要在函数内部修改一个指针的指向,而这个指针本身是在函数外部定义和初始 化的,即希望函数能够改变指针本身所指向的地址。如果仅使用二级指针,函数只能修改 指针指向的内存块的值,而无法改变指针本身指向的地址。代入此题的情况也就是 在 GetStringsA 函数中使用三级指针 (char ***dest),使得函数能够动态分配内存,并在函 数内部修改 dest,确保函数执行后分配的内存在函数外部仍然可以访问。 #GetStringsA1 函数应该如何使用?</p>
<p>答:与 GetStringsA 不同的是,GetStringA1 有返回值,而 GetStringA 无返回值,而是直接 通过指针修改 dest。因此在调用此函数的时候,需要如下:(即先接受返回值再在结束时 释放内存)<br>char **result &#x3D; GetStringsA1(source, n); for(i&#x3D;0; i&lt;n; i++) {<br> free(result[i]);<br>} free(result);</p>
<h4 id="4-Freestrings-函数的形式参数为什么需要用到三级指针"><a href="#4-Freestrings-函数的形式参数为什么需要用到三级指针" class="headerlink" title="4. Freestrings 函数的形式参数为什么需要用到三级指针?"></a>4. Freestrings 函数的形式参数为什么需要用到三级指针?</h4><p>答:当动态分配的内存是通过三级指针来管理时,函数通过操作三级指针可以直接访问和 释放指向字符串数组的指针,以及数组中每个字符串的指针。在释放内存后,为了避免出 现悬空指针的情况,需要将原始指针设为 NULL。通过使用三级指针作为参数,函数可以 修改传入指针的指向,将其置为 NULL。</p>
<h3 id="3-2-不同存储方式能够进行-不能进行的操作方法"><a href="#3-2-不同存储方式能够进行-不能进行的操作方法" class="headerlink" title="3.2 不同存储方式能够进行&#x2F;不能进行的操作方法"></a>3.2 不同存储方式能够进行&#x2F;不能进行的操作方法</h3><p>1、对于 BubbleA:使用数组指针,需要更多内存以及复制操作,对数组的长度有严格要 求。在操作即排序过程中需要频繁地复制字符串内容到 temp 数组中,涉及更多的内存读 写操作。当 NUM 过大的时候,使用 BubbleA 可能不是很方便。但 BubbleA 可以处理 strA,也能处理 strB<br>2、对于 BubbleB:使用指针数组,内存消耗较少,更适合处理不定长字符串或者长度不同 的字符串数组。在操作过程中只需要交换指针,减少了内存操作,可能在大量数据排序时 效率稍高。由于 strA 中的字符串存储在常量池中,所以 BubbleB 不能处理 strA,只能处理 strB。</p>
<p>——————————————————————————————————————————————<br>3、对于字符串数组,使用数组指针通常更适合进行插入和删除操作,因为数组指针可以指 向数组中的任意位置,,使得插入操作更为方便,且如果字符串长度可变或需要动态扩 展,数组指针可以更容易处理这种情况。相比之下,指针数组虽然在某些方面提供了更多 的自由度,但在插入和删除操作上可能会涉及到多个指针的协调,不如数组指针直接和简 洁。</p>
<h3 id="3-3-补充"><a href="#3-3-补充" class="headerlink" title="3.3 补充"></a>3.3 补充</h3><p>对于原 StrCmp(const char *str1, const char *str2)函数来说,进行了一点小小的修改,原函数 为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> </span>&#123;<span class="comment">//修改前的原函数 unsigned char *p1 = (unsigned char*)str1; unsigned char *p2 = (unsigned char*)str2; while(*p1 &amp;&amp; *p2 &amp;&amp; *p1++==*p2++)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> *p1 &gt; *p2 ? <span class="number">1</span> : (*p1&lt;*p2 ? <span class="number">-1</span> : <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如此会出现一个问题,即在于 return 语句,它试图在增加 p1 和 p2 指针后立即返回比 较结果。然而,在循环内部已经对 p1 和 p2 进行了自增操作。这意味着当循环结束时, p1 和 p2 指向的字符已经不相等,但返回语句仍然在比较循环开始时的字符。这种情况 下,返回的比较结果可能是不正确的,特别是对于长字符串或者包含多字节字符的字符 串。</p>
<p>修改后函数为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> </span>&#123; <span class="comment">//修改后的函数 unsigned char *p1 = (unsigned char*)str1; unsigned char *p2 = (unsigned char*)str2; while(*p1 &amp;&amp; *p2 &amp;&amp; *p1==*p2) </span></span><br><span class="line">&#123;</span><br><span class="line">P2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *p1 &gt; *p2 ? <span class="number">1</span> : (*p1&lt;*p2 ? <span class="number">-1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/sort04.png" alt="sort04.png"></p>
<p>由上图 3.1 可知修改之后,strcmp()和 StrCmp()函数具有同样的功能 附 BubbleA 和 BubbleB 的程序:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleA</span><span class="params">(<span class="type">char</span> (*str)[NUM],<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 数组指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//printf(&quot;请完成函数 BubbleA 的定义, 执行排序操作。\n&quot;);</span></span><br><span class="line"><span class="type">char</span> temp[NUM];<span class="comment">// 定义一个局部变量,数据类型与形式数据类型相同 int i, j; for(i=1;i&lt;size;i++) // 共进行 size-1 轮比较和交换</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;size-i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(str[j],str[j<span class="number">+1</span>])&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">strcpy</span>(temp, str[j]); <span class="built_in">strcpy</span>(str[j], str[j<span class="number">+1</span>]);</span><br><span class="line"><span class="built_in">strcpy</span>(str[j<span class="number">+1</span>],temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleB</span><span class="params">(<span class="type">char</span> *str[], <span class="type">int</span> size)</span> <span class="comment">// 指针数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//printf(&quot;请完成函数 BubbleB 的定义,执行排序操作。\n&quot;); char *temp;// 定义一个指针变量,用于交换字符串指针 int i, j; for (i=1;i&lt;size;i++)&#123; // 共进行 size-1 轮比较和交换 for (j=0;j&lt;size-i;j++)&#123;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(str[j],str[j<span class="number">+1</span>])&gt;<span class="number">0</span>) &#123;</span><br><span class="line">temp=str[j];</span><br><span class="line">str[j]=str[j<span class="number">+1</span>];</span><br><span class="line">str[j<span class="number">+1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-小组分工及组员感想"><a href="#4-小组分工及组员感想" class="headerlink" title="4. 小组分工及组员感想"></a>4. 小组分工及组员感想</h1><h3 id="4-1-小组分工说明"><a href="#4-1-小组分工说明" class="headerlink" title="4.1 小组分工说明"></a>4.1 小组分工说明</h3><p>周宸宇:实现并优化快速排序,测试,并进行分析。整合小组成员负责的三种排序算法, 对排序算法及其优化方案联合测试,制作图表分析数据,论文撰写,论文排版。</p>
<p>刘思齐:不同存储方式的 C-字符串排序及思考题、三种排序的稳定性分析。</p>
<p>唐海棠:实现并优化冒泡排序,测试,并进行分析。</p>
<p>彭家正:实现并优化选择排序,测试,并进行分析。</p>
<h1 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h1><p>通过深入参与这门实训课程,我们系统地学习了经典的排序算法及其优化策略。在持 续探索与解决问题的过程中,我们不仅提升了编程技能与算法应用能力,更为后续的专业 学习奠定了坚实的基础。同时,此次实践机会也让我们在团队协作与人际沟通方面得到了 充分的锻炼。在大家的共同努力与协作下,我们顺利完成了实训任务,实现了知识与技能 的双重提升。</p>
<p>致谢 感谢任课老师的谆谆教诲,同时也感谢小组内所有成员的辛勤付出,也相信我 们可以通过此次实训打开进入计算机学院的大门。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>[1]CSDN 技术社区 <a target="_blank" rel="noopener" href="https://blog.csdn.net/chuxinchangcun/article/details/133363649">https://blog.csdn.net/chuxinchangcun/article/details/133363649</a><br>[2]CSDN 技术社区 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38289815/article/details/82718428">https://blog.csdn.net/qq_38289815/article/details/82718428</a><br>[3]CSDN 技术社区 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Kevinnsm/article/details/114448053">https://blog.csdn.net/Kevinnsm/article/details/114448053</a><br>[4]CSDN 技术社区 <a target="_blank" rel="noopener" href="https://blog.csdn.net/fzhhsa/article/details/103113915">https://blog.csdn.net/fzhhsa/article/details/103113915</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://captainjack-ai.github.io">Zhou Chenyu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://captainjack-ai.github.io/2024/11/26/24%E5%A4%8F%E5%AD%A3%E5%AE%9E%E8%AE%AD01%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88Sort%EF%BC%89/">https://captainjack-ai.github.io/2024/11/26/24%E5%A4%8F%E5%AD%A3%E5%AE%9E%E8%AE%AD01%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88Sort%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://captainjack-ai.github.io" target="_blank">悲伤虾滑蛋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Practice/">Practice</a></div><div class="post-share"><div class="social-share" data-image="/img/Picture/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/26/24%E5%88%9B%E6%96%B0%E5%AE%9E%E8%AE%AD01%EF%BC%9AMINST%E8%AF%86%E5%88%AB/" title="24创新实训01：MNIST手写数据集预测（ML）"><img class="cover" src="/img/3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">24创新实训01：MNIST手写数据集预测（ML）</div></div><div class="info-2"><div class="info-item-1">2023-2024 学年秋季学期 创新创业实训一、实训过程简述1 实训概况、实训过程实践概况:本学期在马老师的指导下,借助网络资源学习了机器学习和深度学习的一些 入门知识,了解了一些基础的概念,模型背后的数学原理,也动手实践做了一个通过全连接 神经网络模型来预测手写数字集的小项目,加深了我对理论知识的理解。 实践过程:学期初,我在网络上学习了北京邮电大学鲁鹏老师的计算机视觉与深度学习 的课程,这门课主要是讲解一些分类器模型背后的数学原理,我分别听了图像分类任务,线 性分类器,全连接神经网络以及卷积的相关课程。学习了如何构建模型、通过损失函数刻画 模型性能,并利用优化算法更新模型权值等基础的机器学习与深度学习知识。 更为具体一点来说,在课程中我学习到了多类支撑向量机损失,交叉熵损失,正则损失 三种具有不同的特点的损失函数来刻画模型的预测性能;此外优化算法方面,我了解了梯度 下降算法,以及在其基础上优化形成的小批量随机梯度下降算法。全连接神经网络方面,我 了解了激活函数对线性分类器进行的非线性操作,使得模型可以处理更为复杂的分类任务;...</div></div></div></a><a class="pagination-related" href="/2024/11/26/%E5%8D%B7%E7%A7%AF%EF%BC%88Convolution%EF%BC%89/" title="信号处理02：卷积（Convolution）"><img class="cover" src="/img/Picture/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">信号处理02：卷积（Convolution）</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/26/24%E5%88%9B%E6%96%B0%E5%AE%9E%E8%AE%AD01%EF%BC%9AMINST%E8%AF%86%E5%88%AB/" title="24创新实训01：MNIST手写数据集预测（ML）"><img class="cover" src="/img/3.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-26</div><div class="info-item-2">24创新实训01：MNIST手写数据集预测（ML）</div></div><div class="info-2"><div class="info-item-1">2023-2024 学年秋季学期 创新创业实训一、实训过程简述1 实训概况、实训过程实践概况:本学期在马老师的指导下,借助网络资源学习了机器学习和深度学习的一些 入门知识,了解了一些基础的概念,模型背后的数学原理,也动手实践做了一个通过全连接 神经网络模型来预测手写数字集的小项目,加深了我对理论知识的理解。 实践过程:学期初,我在网络上学习了北京邮电大学鲁鹏老师的计算机视觉与深度学习 的课程,这门课主要是讲解一些分类器模型背后的数学原理,我分别听了图像分类任务,线 性分类器,全连接神经网络以及卷积的相关课程。学习了如何构建模型、通过损失函数刻画 模型性能,并利用优化算法更新模型权值等基础的机器学习与深度学习知识。 更为具体一点来说,在课程中我学习到了多类支撑向量机损失,交叉熵损失,正则损失 三种具有不同的特点的损失函数来刻画模型的预测性能;此外优化算法方面,我了解了梯度 下降算法,以及在其基础上优化形成的小批量随机梯度下降算法。全连接神经网络方面,我 了解了激活函数对线性分类器进行的非线性操作,使得模型可以处理更为复杂的分类任务;...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zhou Chenyu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/CaptainJack-ai" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:shuzhouchenyu@icloud.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p>欢迎来到我的个人网站！</p>
<p>🙋‍♂️是谁？<br>—— 一个代码工匠,热衷解决“BUG星人”的入侵;</p>
<p>🎵 会做啥？<br>—— 不止会码代码，还会弹吉他和玩架子鼓！</p>
<p>🏓 兴趣？<br>—— 乒乓球、音乐、写博客，偶尔研究新技术，整点小创新！</p>
<p>欢迎探索我的网站，有疑问或建议，直接留言吧！😄<br>Enjoy your stay 🎉</p>
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%E5%8F%8A%E5%85%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">经典排序算法的优化及其测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Optimization-And-Testing-Of-Classical-Sorting-Algorithm"><span class="toc-number">1.0.1.</span> <span class="toc-text">Optimization And Testing Of Classical Sorting Algorithm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%BC%95%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">1.引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A0%94%E7%A9%B6"><span class="toc-number">3.</span> <span class="toc-text">2. 经典排序算法的研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%81%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 排序算法的实现、优化及测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%9F%BA%E7%A1%80%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">A.基础冒泡排序实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E4%BC%98%E5%8C%96-%E5%8E%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.1.2.</span> <span class="toc-text">B. 优化:去除不必要的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%B5%8B%E8%AF%95-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">C. 算法分析与测试 算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">1. 空间复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">2. 稳定性分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">3. 时间复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-number">3.1.3.4.</span> <span class="toc-text">测试数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.4.</span> <span class="toc-text">A.基础快速排序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E4%BC%98%E5%8C%96-1-%E4%BC%98%E5%8C%96%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%9F%BA%E5%87%86%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">B. 优化 1:优化快速排序基准的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">实现三数取中的代码如下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%BC%98%E5%8C%96-2-%E5%BA%8F%E5%88%97%E9%95%BF%E5%BA%A6%E8%BE%BE%E5%88%B0%E4%B8%80%E5%AE%9A%E5%A4%A7%E5%B0%8F%E5%90%8E-%E4%BD%BF%E7%94%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">C. 优化 2:序列长度达到一定大小后,使用插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#D-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.4.3.1.</span> <span class="toc-text">D. 算法分析与测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90-1"><span class="toc-number">3.1.4.3.2.</span> <span class="toc-text">2. 稳定性分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">3.1.4.3.3.</span> <span class="toc-text">3. 时间复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">3.1.5.</span> <span class="toc-text">对整型数据测试结果的分析:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">对浮点型数据测试结果的分析:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selection-Sort-%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%81%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B5%8B%E8%AF%95-A-%E5%9F%BA%E7%A1%80%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.6.</span> <span class="toc-text">2.1.3 选择排序(Selection Sort)的实现、优化及测试 A.基础选择排序实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E4%BC%98%E5%8C%96-%E4%BC%98%E5%8C%96%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%9C%A8%E9%81%8D%E5%8E%86%E4%B8%AD%E6%AF%94%E8%BE%83%E5%80%BC%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">3.1.7.</span> <span class="toc-text">B. 优化:优化选择排序在遍历中比较值的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.8.</span> <span class="toc-text">C. 算法分析与测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BC%98%E5%8C%96%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.8.1.</span> <span class="toc-text">(2) 优化选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.1.8.2.</span> <span class="toc-text">3. 时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BC%98%E5%8C%96%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-1"><span class="toc-number">3.1.8.3.</span> <span class="toc-text">(2) 优化选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">3.1.8.4.</span> <span class="toc-text">对双精度浮点数据测试结果的分析:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%A4%9A%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E8%81%94%E5%90%88%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.9.</span> <span class="toc-text">2.2 多种排序算法的联合测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE-2-2-2"><span class="toc-number">3.1.9.1.</span> <span class="toc-text">图 2.2.2</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-3-%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">2.3 三种经典排序算法稳定性分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%A0%94%E7%A9%B6"><span class="toc-number">5.</span> <span class="toc-text">3. C-字符串数组排序研究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">5.0.1.</span> <span class="toc-text">3.1 思考题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E4%B8%AD"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">1. 下面的测试函数中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1-Bubblea-Bubbleb-%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D-%E6%80%9D%E8%80%83"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">2.设计 Bubblea,Bubbleb 两个函数之前,思考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%85%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">5.0.1.3.</span> <span class="toc-text">仅用二级指针会怎样?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Freestrings-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E4%B8%89%E7%BA%A7%E6%8C%87%E9%92%88"><span class="toc-number">5.0.1.4.</span> <span class="toc-text">4. Freestrings 函数的形式参数为什么需要用到三级指针?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E8%83%BD%E5%A4%9F%E8%BF%9B%E8%A1%8C-%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.2.</span> <span class="toc-text">3.2 不同存储方式能够进行&#x2F;不能进行的操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%A1%A5%E5%85%85"><span class="toc-number">5.0.3.</span> <span class="toc-text">3.3 补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%84%E5%88%86%E5%B7%A5%E5%8F%8A%E7%BB%84%E5%91%98%E6%84%9F%E6%83%B3"><span class="toc-number">6.</span> <span class="toc-text">4. 小组分工及组员感想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%B0%8F%E7%BB%84%E5%88%86%E5%B7%A5%E8%AF%B4%E6%98%8E"><span class="toc-number">6.0.1.</span> <span class="toc-text">4.1 小组分工说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%BB%93%E8%AF%AD"><span class="toc-number">7.</span> <span class="toc-text">5. 结语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404%EF%BC%9A%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-KMP/" title="数据结构04：模式匹配算法--KMP"><img src="/img/Picture/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构04：模式匹配算法--KMP"/></a><div class="content"><a class="title" href="/2024/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404%EF%BC%9A%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-KMP/" title="数据结构04：模式匹配算法--KMP">数据结构04：模式匹配算法--KMP</a><time datetime="2024-12-24T06:20:44.000Z" title="发表于 2024-12-24 14:20:44">2024-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%9003%EF%BC%9A%E6%9C%BA%E5%99%A8%E7%A0%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/" title="计算机组成03：机器码的四种表示方法"><img src="/img/Picture/0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成03：机器码的四种表示方法"/></a><div class="content"><a class="title" href="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%9003%EF%BC%9A%E6%9C%BA%E5%99%A8%E7%A0%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/" title="计算机组成03：机器码的四种表示方法">计算机组成03：机器码的四种表示方法</a><time datetime="2024-12-10T13:06:20.000Z" title="发表于 2024-12-10 21:06:20">2024-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403%EF%BC%9A%E5%85%B1%E4%BA%AB%E6%A0%88%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88ShareStack%EF%BC%89/" title="数据结构03：共享栈的设计（ShareStack）"><img src="/img/Picture/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构03：共享栈的设计（ShareStack）"/></a><div class="content"><a class="title" href="/2024/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403%EF%BC%9A%E5%85%B1%E4%BA%AB%E6%A0%88%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88ShareStack%EF%BC%89/" title="数据结构03：共享栈的设计（ShareStack）">数据结构03：共享栈的设计（ShareStack）</a><time datetime="2024-12-10T08:37:02.000Z" title="发表于 2024-12-10 16:37:02">2024-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%9002%EF%BC%9A%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E4%B8%B2%E8%A1%8C%E8%BF%9B%E4%BD%8D%E5%92%8C%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D/" title="计算机组成02：加法器的串行进位和并行进位"><img src="/img/Picture/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成02：加法器的串行进位和并行进位"/></a><div class="content"><a class="title" href="/2024/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%9002%EF%BC%9A%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E4%B8%B2%E8%A1%8C%E8%BF%9B%E4%BD%8D%E5%92%8C%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D/" title="计算机组成02：加法器的串行进位和并行进位">计算机组成02：加法器的串行进位和并行进位</a><time datetime="2024-12-08T11:00:48.000Z" title="发表于 2024-12-08 19:00:48">2024-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%8601%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/" title="计算机组成原理01——总结"><img src="/img/Picture/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成原理01——总结"/></a><div class="content"><a class="title" href="/2024/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%8601%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/" title="计算机组成原理01——总结">计算机组成原理01——总结</a><time datetime="2024-12-08T08:51:14.000Z" title="发表于 2024-12-08 16:51:14">2024-12-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/Picture/1.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Zhou Chenyu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>